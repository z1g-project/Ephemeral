{
  "version": 3,
  "sources": ["../../src/rewrite/headers.ts", "../../src/util/TypedEmitter.ts", "../../src/worker.ts"],
  "sourcesContent": ["/*\n  Other files within the /rewrite directory are for both client and server use.\n  This file, due to it's server only nature, should never import anything from\n  the /rewrite directory. Instead it should use the __$ampere global.\n*/\n\nexport function outgoing(headers: Headers, meta: string | URL): Headers {\n  headers.set(\"Origin\", new URL(meta).origin);\n  headers.set(\"Host\", new URL(meta).host);\n  headers.set(\"Referer\", meta.toString());\n\n  return headers;\n}\n\nexport function incoming(headers: Headers, meta: string | URL): Headers {\n  // Temporarily remove CSP headers until we do CSP emulation\n  headers.delete(\"content-security-policy\");\n  headers.delete(\"content-security-policy-report-only\");\n\n  return headers;\n}\n", "export class TypedEmitter<\n  T extends { [K in keyof T]: (...args: any[]) => any }\n> {\n  private listeners: { [K in keyof T]: Array<T[K]> } = {} as any;\n\n  public on<K extends keyof T>(event: K, listener: T[K]) {\n    if (!this.listeners[event]) this.listeners[event] = [];\n    this.listeners[event].push(listener);\n  }\n\n  public once<K extends keyof T>(event: K, listener: T[K]) {\n    const onceListener = ((...args) => {\n      this.off(event, onceListener);\n      return listener(...args);\n    }) as T[K];\n\n    this.on(event, onceListener);\n  }\n\n  public off<K extends keyof T>(event: K, listener: T[K]) {\n    if (!this.listeners[event]) return;\n    this.listeners[event] = this.listeners[event].filter((l) => l !== listener);\n  }\n\n  public async emit<K extends keyof T>(event: K, ...args: Parameters<T[K]>) {\n    let value: ReturnType<T[K]> | undefined;\n\n    if (!this.listeners[event]) return;\n    for (const listener of this.listeners[event]) {\n      value = (await listener(...args)) ?? value;\n    }\n\n    return value;\n  }\n}\n", "/// <reference lib=\"webworker\" />\nimport { incoming, outgoing } from \"./rewrite/headers\";\nimport { ProxyWorker, WorkerEvents } from \"./util/ProxyWorker\";\nimport { TypedEmitter } from \"./util/TypedEmitter\";\n\ndeclare var self: ServiceWorkerGlobalScope & {\n  AmpereWorker: typeof AmpereWorker;\n};\n\nexport class AmpereWorker\n  extends TypedEmitter<WorkerEvents>\n  implements ProxyWorker\n{\n  ready: Promise<void>;\n\n  constructor() {\n    super();\n\n    // Load plugins\n    for (const plugin of __$ampere.config.plugins) {\n      try {\n        if (plugin.worker) {\n          __$ampere.logger.info(\"Loading plugin\", plugin.name);\n          plugin.worker(this);\n          __$ampere.logger.info(\"Loaded plugin\", plugin.name);\n        }\n      } catch (e) {\n        __$ampere.logger.error(\"Failed to load plugin\", plugin.name, e);\n      }\n    }\n\n    // For now we just resolve immediately\n    // eventually we will need to open IDB connections and such\n    this.ready = Promise.resolve();\n\n    self.addEventListener(\"install\", () => {\n      __$ampere.logger.info(\"Service Worker installed\");\n    });\n  }\n\n  async makeRequest(url: URL, init: RequestInit): Promise<Response> {\n    __$ampere.logger.info(\"Fetching\", url.href);\n\n    return await __$ampere.bareClient.fetch(url, init);\n  }\n\n  async fetch(event: FetchEvent): Promise<Response> {\n    // wait for the SW to be ready\n    await this.ready;\n\n    // allow any internal scripts to load\n    const { files } = __$ampere.config;\n    const ampereUrls = [\n      files.config,\n      files.client,\n      files.worker,\n      files.bundle\n    ].map((file) => files.directory + file);\n\n    const url = new URL(event.request.url);\n\n    // If the request is for a ampere file, we just fetch it\n    if (ampereUrls.includes(url.pathname)) {\n      __$ampere.logger.info(\"Loading ampere script\", url.href);\n      return fetch(event.request);\n    }\n\n    // Otherwise we proxy the request to the server\n    const rawProxyURL =\n      __$ampere.unwriteURL(url.pathname) + url.search + url.hash;\n\n    // If the URL contains a hash or search (non-encoded data) we redirect to the encoded URL\n    // BUG: This may cause POST requests to be redirected to GET requests from form submits\n    // Either handle form submits on the client or allow non-encoded data in the URL\n    if (url.search || url.hash) {\n      __$ampere.logger.debug(\n        \"Detected non-encoded data in URL, redirecting from\",\n        url.href,\n        \"to\",\n        __$ampere.rewriteURL(rawProxyURL, url)\n      );\n\n      return new Response(null, {\n        status: 301,\n        headers: {\n          location: __$ampere.rewriteURL(rawProxyURL, url)\n        }\n      });\n    }\n\n    // error checking on URL\n    try {\n      new URL(rawProxyURL);\n    } catch {\n      __$ampere.logger.error(\"Decoded URL is invalid\", rawProxyURL);\n      return new Response(\"Invalid URL\", { status: 400 });\n    }\n\n    const proxyURL = new URL(rawProxyURL);\n\n    // request init for outgoing bare request\n    const requestInit: RequestInit & { duplex: \"half\" } = {\n      method: event.request.method,\n      headers: Object.fromEntries(event.request.headers),\n      redirect: \"manual\",\n      // Typescript doesn't believe in duplex but it's required for certain requests (and yes it's in the spec)\n      duplex: \"half\"\n    };\n\n    // request body for non-GET/HEAD requests\n    if (![\"GET\", \"HEAD\"].includes(event.request.method)) {\n      requestInit.body = event.request.body;\n    }\n\n    // create a request object\n    let request = new Request(proxyURL, requestInit);\n    const requestHeaders = outgoing(new Headers(requestInit.headers), proxyURL);\n\n    // make headers mutable\n    Object.defineProperty(request, \"headers\", {\n      get() {\n        return requestHeaders;\n      }\n    });\n\n    // emit request event\n    request = (await this.emit(\"request\", request)) ?? request;\n\n    // make a request to the server\n    const bareRequest = await this.makeRequest(proxyURL, requestInit);\n\n    // handle redirects\n    if (\n      bareRequest.status >= 300 &&\n      bareRequest.status < 400 &&\n      bareRequest.headers.has(\"location\")\n    ) {\n      __$ampere.logger.debug(\n        \"Redirecting from\",\n        proxyURL.href,\n        \"to\",\n        bareRequest.headers.get(\"location\")\n      );\n\n      return new Response(null, {\n        status: 301,\n        headers: {\n          location: __$ampere.rewriteURL(\n            bareRequest.headers.get(\"location\") as string,\n            proxyURL\n          )\n        }\n      });\n    }\n\n    // response init for outgoing response\n    const responseInit: ResponseInit = {\n      status: bareRequest.status,\n      statusText: bareRequest.statusText,\n      headers: incoming(bareRequest.headers, proxyURL)\n    };\n\n    let responseBody: BodyInit | null;\n    if ([101, 204, 205, 304].includes(bareRequest.status)) {\n      // null response body for certain status codes\n      responseBody = null;\n      __$ampere.logger.info(\"Returning empty response for\", proxyURL.href);\n    } else if (bareRequest.headers.get(\"content-type\")?.includes(\"text/html\")) {\n      __$ampere.logger.info(\"Rewriting HTML for\", proxyURL.href);\n      // Scope HTML\n      let html = await bareRequest.text();\n\n      // emit html event\n      html = (await this.emit(\"html\", html)) ?? html;\n\n      responseBody = __$ampere.rewriteHTML(html, proxyURL);\n    } else if (\n      bareRequest.headers\n        .get(\"content-type\")\n        ?.includes(\"application/javascript\") ||\n      // use || destination for non-strict mime type matching\n      [\"script\", \"sharedworker\", \"worker\"].includes(event.request.destination)\n    ) {\n      __$ampere.logger.info(\"Rewriting JS for\", proxyURL.href);\n      // rewrite JS\n      let js = await bareRequest.text();\n\n      // emit js event\n      js = (await this.emit(\"js\", js)) ?? js;\n\n      responseBody = __$ampere.rewriteJS(js, proxyURL);\n    } else if (\n      bareRequest.headers.get(\"content-type\")?.includes(\"text/css\") ||\n      // use || destination for non-strict mime type matching\n      [\"style\"].includes(event.request.destination)\n    ) {\n      __$ampere.logger.info(\"Rewriting CSS for\", proxyURL.href);\n      // rewrite CSS\n      let css = await bareRequest.text();\n\n      // emit css event\n      css = (await this.emit(\"css\", css)) ?? css;\n\n      responseBody = __$ampere.rewriteCSS(css, proxyURL);\n    } else if (event.request.destination === \"manifest\") {\n      let manifest = await bareRequest.text();\n\n      // emit manifest event\n      manifest = (await this.emit(\"manifest\", manifest)) ?? manifest;\n\n      responseBody = __$ampere.rewriteManifest(manifest, proxyURL);\n    } else {\n      __$ampere.logger.info(\"Returning binary for\", proxyURL.href);\n      responseBody = bareRequest.body;\n    }\n\n    let response = new Response(responseBody, responseInit);\n\n    // emit response event\n    response = (await this.emit(\"response\", response)) ?? response;\n\n    return response;\n  }\n}\n\nself.AmpereWorker = AmpereWorker;\n"],
  "mappings": "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",
  "names": []
}
