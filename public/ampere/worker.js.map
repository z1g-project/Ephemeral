{
  "version": 3,
  "sources": ["../../node_modules/set-cookie-parser/lib/set-cookie.js", "../../node_modules/idb/build/index.js", "../../src/util/CookieDB.ts", "../../src/util/cookie.ts", "../../src/rewrite/headers.ts", "../../src/util/TypedEmitter.ts", "../../src/worker.ts"],
  "sourcesContent": ["\"use strict\";\n\nvar defaultParseOptions = {\n  decodeValues: true,\n  map: false,\n  silent: false,\n};\n\nfunction isNonEmptyString(str) {\n  return typeof str === \"string\" && !!str.trim();\n}\n\nfunction parseString(setCookieValue, options) {\n  var parts = setCookieValue.split(\";\").filter(isNonEmptyString);\n\n  var nameValuePairStr = parts.shift();\n  var parsed = parseNameValuePair(nameValuePairStr);\n  var name = parsed.name;\n  var value = parsed.value;\n\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  try {\n    value = options.decodeValues ? decodeURIComponent(value) : value; // decode cookie value\n  } catch (e) {\n    console.error(\n      \"set-cookie-parser encountered an error while decoding a cookie with value '\" +\n        value +\n        \"'. Set options.decodeValues to false to disable this feature.\",\n      e\n    );\n  }\n\n  var cookie = {\n    name: name,\n    value: value,\n  };\n\n  parts.forEach(function (part) {\n    var sides = part.split(\"=\");\n    var key = sides.shift().trimLeft().toLowerCase();\n    var value = sides.join(\"=\");\n    if (key === \"expires\") {\n      cookie.expires = new Date(value);\n    } else if (key === \"max-age\") {\n      cookie.maxAge = parseInt(value, 10);\n    } else if (key === \"secure\") {\n      cookie.secure = true;\n    } else if (key === \"httponly\") {\n      cookie.httpOnly = true;\n    } else if (key === \"samesite\") {\n      cookie.sameSite = value;\n    } else {\n      cookie[key] = value;\n    }\n  });\n\n  return cookie;\n}\n\nfunction parseNameValuePair(nameValuePairStr) {\n  // Parses name-value-pair according to rfc6265bis draft\n\n  var name = \"\";\n  var value = \"\";\n  var nameValueArr = nameValuePairStr.split(\"=\");\n  if (nameValueArr.length > 1) {\n    name = nameValueArr.shift();\n    value = nameValueArr.join(\"=\"); // everything after the first =, joined by a \"=\" if there was more than one part\n  } else {\n    value = nameValuePairStr;\n  }\n\n  return { name: name, value: value };\n}\n\nfunction parse(input, options) {\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  if (!input) {\n    if (!options.map) {\n      return [];\n    } else {\n      return {};\n    }\n  }\n\n  if (input.headers) {\n    if (typeof input.headers.getSetCookie === \"function\") {\n      // for fetch responses - they combine headers of the same type in the headers array,\n      // but getSetCookie returns an uncombined array\n      input = input.headers.getSetCookie();\n    } else if (input.headers[\"set-cookie\"]) {\n      // fast-path for node.js (which automatically normalizes header names to lower-case\n      input = input.headers[\"set-cookie\"];\n    } else {\n      // slow-path for other environments - see #25\n      var sch =\n        input.headers[\n          Object.keys(input.headers).find(function (key) {\n            return key.toLowerCase() === \"set-cookie\";\n          })\n        ];\n      // warn if called on a request-like object with a cookie header rather than a set-cookie header - see #34, 36\n      if (!sch && input.headers.cookie && !options.silent) {\n        console.warn(\n          \"Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.\"\n        );\n      }\n      input = sch;\n    }\n  }\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n\n  options = options\n    ? Object.assign({}, defaultParseOptions, options)\n    : defaultParseOptions;\n\n  if (!options.map) {\n    return input.filter(isNonEmptyString).map(function (str) {\n      return parseString(str, options);\n    });\n  } else {\n    var cookies = {};\n    return input.filter(isNonEmptyString).reduce(function (cookies, str) {\n      var cookie = parseString(str, options);\n      cookies[cookie.name] = cookie;\n      return cookies;\n    }, cookies);\n  }\n}\n\n/*\n  Set-Cookie header field-values are sometimes comma joined in one string. This splits them without choking on commas\n  that are within a single set-cookie field-value, such as in the Expires portion.\n\n  This is uncommon, but explicitly allowed - see https://tools.ietf.org/html/rfc2616#section-4.2\n  Node.js does this for every header *except* set-cookie - see https://github.com/nodejs/node/blob/d5e363b77ebaf1caf67cd7528224b651c86815c1/lib/_http_incoming.js#L128\n  React Native's fetch does this for *every* header, including set-cookie.\n\n  Based on: https://github.com/google/j2objc/commit/16820fdbc8f76ca0c33472810ce0cb03d20efe25\n  Credits to: https://github.com/tomball for original and https://github.com/chrusart for JavaScript implementation\n*/\nfunction splitCookiesString(cookiesString) {\n  if (Array.isArray(cookiesString)) {\n    return cookiesString;\n  }\n  if (typeof cookiesString !== \"string\") {\n    return [];\n  }\n\n  var cookiesStrings = [];\n  var pos = 0;\n  var start;\n  var ch;\n  var lastComma;\n  var nextStart;\n  var cookiesSeparatorFound;\n\n  function skipWhitespace() {\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n      pos += 1;\n    }\n    return pos < cookiesString.length;\n  }\n\n  function notSpecialChar() {\n    ch = cookiesString.charAt(pos);\n\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n  }\n\n  while (pos < cookiesString.length) {\n    start = pos;\n    cookiesSeparatorFound = false;\n\n    while (skipWhitespace()) {\n      ch = cookiesString.charAt(pos);\n      if (ch === \",\") {\n        // ',' is a cookie separator if we have later first '=', not ';' or ','\n        lastComma = pos;\n        pos += 1;\n\n        skipWhitespace();\n        nextStart = pos;\n\n        while (pos < cookiesString.length && notSpecialChar()) {\n          pos += 1;\n        }\n\n        // currently special character\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n          // we found cookies separator\n          cookiesSeparatorFound = true;\n          // pos is inside the next cookie, so back up and return it.\n          pos = nextStart;\n          cookiesStrings.push(cookiesString.substring(start, lastComma));\n          start = pos;\n        } else {\n          // in param ',' or param separator ';',\n          // we continue from that comma\n          pos = lastComma + 1;\n        }\n      } else {\n        pos += 1;\n      }\n    }\n\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n      cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n    }\n  }\n\n  return cookiesStrings;\n}\n\nmodule.exports = parse;\nmodule.exports.parse = parse;\nmodule.exports.parseString = parseString;\nmodule.exports.splitCookiesString = splitCookiesString;\n", "const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n", "import { openDB, IDBPDatabase } from \"idb\";\r\nimport { Cookie } from \"set-cookie-parser\";\r\n\r\nexport class CookieDB {\r\n  db: Promise<\r\n    IDBPDatabase<{\r\n      cookies: {\r\n        key: string;\r\n        value: Cookie;\r\n      };\r\n    }>\r\n  >;\r\n\r\n  constructor() {\r\n    this.db = openDB(\"__$ampere\", 1, {\r\n      upgrade(db) {\r\n        db.createObjectStore(\"cookies\");\r\n      }\r\n    });\r\n  }\r\n\r\n  async findCookies(domain: string, path: string): Promise<Cookie[]> {\r\n    const db = await this.db;\r\n\r\n    const allCookies = await db.getAll(\"cookies\");\r\n\r\n    const cookies = allCookies.filter(\r\n      (cookie) =>\r\n        domainMatch(domain, cookie.domain ?? \"\") &&\r\n        pathMatch(path, cookie.path ?? \"/\")\r\n    );\r\n\r\n    return cookies;\r\n  }\r\n\r\n  async putCookie(cookie: Cookie): Promise<void> {\r\n    const db = await this.db;\r\n\r\n    cookie.domain = cookie.domain?.replace(/^\\./, \"\");\r\n\r\n    await db.put(\r\n      \"cookies\",\r\n      cookie,\r\n      `${cookie.domain}:${cookie.path}:${cookie.name}`\r\n    );\r\n  }\r\n\r\n  async removeCookie(domain: string, path: string, key: string): Promise<void> {\r\n    const db = await this.db;\r\n\r\n    await db.delete(\"cookies\", `${domain}:${path}:${key}`);\r\n  }\r\n\r\n  async removeCookies(domain: string, path: string): Promise<void> {\r\n    const db = await this.db;\r\n\r\n    const cookies = await db.getAll(\"cookies\");\r\n\r\n    for (const cookie of cookies) {\r\n      if (cookie.domain === domain && cookie.path === path) {\r\n        await db.delete(\r\n          \"cookies\",\r\n          `${cookie.domain}:${cookie.path}:${cookie.name}`\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  async removeAllCookies(): Promise<void> {\r\n    const db = await this.db;\r\n\r\n    await db.clear(\"cookies\");\r\n  }\r\n\r\n  async getAllCookies(): Promise<Cookie[]> {\r\n    const db = await this.db;\r\n\r\n    const cookies = await db.getAll(\"cookies\");\r\n\r\n    return cookies;\r\n  }\r\n}\r\n\r\nconst IP_REGEX =\r\n  /(?:^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$)|(?:^(?:(?:[a-f\\d]{1,4}:){7}(?:[a-f\\d]{1,4}|:)|(?:[a-f\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-f\\d]{1,4}|:)|(?:[a-f\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,2}|:)|(?:[a-f\\d]{1,4}:){4}(?:(?::[a-f\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,3}|:)|(?:[a-f\\d]{1,4}:){3}(?:(?::[a-f\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,4}|:)|(?:[a-f\\d]{1,4}:){2}(?:(?::[a-f\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,5}|:)|(?:[a-f\\d]{1,4}:){1}(?:(?::[a-f\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,6}|:)|(?::(?:(?::[a-f\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-f\\d]{1,4}){1,7}|:)))$)/;\r\n\r\nexport function domainMatch(domStr: string, str: string): boolean | null {\r\n  if (str == domStr) {\r\n    return true;\r\n  }\r\n\r\n  const i = str.lastIndexOf(domStr);\r\n  if (i <= 0) {\r\n    return false;\r\n  }\r\n\r\n  if (str.length !== domStr.length + i) {\r\n    return false;\r\n  }\r\n\r\n  if (str.substr(i - 1, 1) !== \".\") {\r\n    return false;\r\n  }\r\n\r\n  return !IP_REGEX.test(str);\r\n}\r\n\r\nexport function pathMatch(reqPath: string, cookiePath: string): boolean {\r\n  if (cookiePath === reqPath) {\r\n    return true;\r\n  }\r\n\r\n  const i = reqPath.indexOf(cookiePath);\r\n  if (i === 0) {\r\n    if (cookiePath[cookiePath.length - 1] === \"/\") {\r\n      return true;\r\n    }\r\n\r\n    if (\r\n      new RegExp(`^${cookiePath}`).test(reqPath) &&\r\n      reqPath[cookiePath.length] === \"/\"\r\n    ) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  return false;\r\n}\r\n", "import { CookieDB, domainMatch, pathMatch } from \"./CookieDB\";\r\nimport { parse } from \"set-cookie-parser\";\r\n\r\nexport const cookieJar = new CookieDB();\r\n\r\nexport async function setCookie(\r\n  cookieString: string,\r\n  meta: string | URL\r\n): Promise<void> {\r\n  const cookie = parse(cookieString, {\r\n    decodeValues: true,\r\n    silent: true\r\n  })[0];\r\n\r\n  if (!cookie.domain) {\r\n    cookie.domain = new URL(meta).host;\r\n  }\r\n\r\n  if (!cookie.path) {\r\n    cookie.path = \"/\";\r\n  }\r\n\r\n  if (cookie.expires) {\r\n    if (cookie.expires.getTime() < Date.now()) {\r\n      if (\r\n        domainMatch(new URL(meta).host, cookie.domain) &&\r\n        pathMatch(new URL(meta).pathname, cookie.path)\r\n      ) {\r\n        await cookieJar.removeCookie(cookie.domain, cookie.path, cookie.name);\r\n      } else {\r\n        __$ampere.logger.warn(\r\n          \"Attempted to set cookie for invalid domain or path.\",\r\n          cookieString\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  if (\r\n    domainMatch(new URL(meta).host, cookie.domain) &&\r\n    pathMatch(new URL(meta).pathname, cookie.path)\r\n  ) {\r\n    await cookieJar.putCookie(cookie);\r\n  } else {\r\n    __$ampere.logger.warn(\r\n      \"Attempted to set cookie for invalid domain or path.\",\r\n      cookieString\r\n    );\r\n  }\r\n}\r\n\r\nexport async function getCookie(\r\n  meta: string | URL\r\n): Promise<string | undefined> {\r\n  const cookies = await cookieJar.findCookies(\r\n    new URL(meta).host,\r\n    new URL(meta).pathname\r\n  );\r\n\r\n  return cookies.map((cookie) => `${cookie.name}=${cookie.value}`).join(\"; \");\r\n}\r\n", "/*\r\n  Other files within the /rewrite directory are for both client and server use.\r\n  This file, due to it's server only nature, should never import anything from\r\n  the /rewrite directory. Instead it should use the __$ampere global.\r\n*/\r\nimport { setCookie, getCookie } from \"../util/cookie\";\r\n\r\nexport async function outgoing(\r\n  headers: Headers,\r\n  meta: string | URL\r\n): Promise<Headers> {\r\n  headers.set(\"Origin\", new URL(meta).origin);\r\n  headers.set(\"Host\", new URL(meta).host);\r\n  headers.set(\"Referer\", meta.toString());\r\n\r\n  const cookie = await getCookie(meta);\r\n\r\n  __$ampere.logger.debug(\"Cookie\", cookie);\r\n\r\n  if (cookie !== undefined) {\r\n    headers.set(\"Cookie\", cookie || \"\");\r\n  }\r\n\r\n  return headers;\r\n}\r\n\r\nexport async function incoming(\r\n  headers: Headers,\r\n  meta: string | URL\r\n): Promise<Headers> {\r\n  // Temporarily remove CSP headers until we do CSP emulation\r\n  headers.delete(\"content-security-policy\");\r\n  headers.delete(\"content-security-policy-report-only\");\r\n\r\n  const cookies = headers.getSetCookie();\r\n\r\n  for (const cookie of cookies) {\r\n    await setCookie(cookie, meta);\r\n  }\r\n\r\n  return headers;\r\n}\r\n", "export class TypedEmitter<\r\n  T extends { [K in keyof T]: (...args: any[]) => any }\r\n> {\r\n  private listeners: { [K in keyof T]: Array<T[K]> } = {} as any;\r\n\r\n  public on<K extends keyof T>(event: K, listener: T[K]) {\r\n    if (!this.listeners[event]) this.listeners[event] = [];\r\n    this.listeners[event].push(listener);\r\n  }\r\n\r\n  public once<K extends keyof T>(event: K, listener: T[K]) {\r\n    const onceListener = ((...args) => {\r\n      this.off(event, onceListener);\r\n      return listener(...args);\r\n    }) as T[K];\r\n\r\n    this.on(event, onceListener);\r\n  }\r\n\r\n  public off<K extends keyof T>(event: K, listener: T[K]) {\r\n    if (!this.listeners[event]) return;\r\n    this.listeners[event] = this.listeners[event].filter((l) => l !== listener);\r\n  }\r\n\r\n  public async emit<K extends keyof T>(event: K, ...args: Parameters<T[K]>) {\r\n    let value: ReturnType<T[K]> | undefined;\r\n\r\n    if (!this.listeners[event]) return;\r\n    for (const listener of this.listeners[event]) {\r\n      value = (await listener(...args)) ?? value;\r\n    }\r\n\r\n    return value;\r\n  }\r\n}\r\n", "/// <reference lib=\"webworker\" />\r\nimport { incoming, outgoing } from \"./rewrite/headers\";\r\nimport { ProxyWorker, WorkerEvents } from \"./util/ProxyWorker\";\r\nimport { TypedEmitter } from \"./util/TypedEmitter\";\r\n\r\ndeclare var self: ServiceWorkerGlobalScope & {\r\n  AmpereWorker: typeof AmpereWorker;\r\n};\r\n\r\nexport class AmpereWorker\r\n  extends TypedEmitter<WorkerEvents>\r\n  implements ProxyWorker\r\n{\r\n  ready: Promise<void>;\r\n\r\n  constructor() {\r\n    super();\r\n\r\n    // Load plugins\r\n    for (const plugin of __$ampere.config.plugins) {\r\n      try {\r\n        if (plugin.worker) {\r\n          __$ampere.logger.info(\"Loading plugin\", plugin.name);\r\n          plugin.worker(this);\r\n          __$ampere.logger.info(\"Loaded plugin\", plugin.name);\r\n        }\r\n      } catch (e) {\r\n        __$ampere.logger.error(\"Failed to load plugin\", plugin.name, e);\r\n      }\r\n    }\r\n\r\n    // For now we just resolve immediately\r\n    // eventually we will need to open IDB connections and such\r\n    this.ready = Promise.resolve();\r\n\r\n    self.addEventListener(\"install\", () => {\r\n      __$ampere.logger.info(\"Service Worker installed\");\r\n    });\r\n  }\r\n\r\n  async makeRequest(url: URL, init: RequestInit): Promise<Response> {\r\n    __$ampere.logger.info(\"Fetching\", url.href, init);\r\n\r\n    return await __$ampere.bareClient.fetch(url, init);\r\n  }\r\n\r\n  async fetch(event: FetchEvent): Promise<Response> {\r\n    // wait for the SW to be ready\r\n    await this.ready;\r\n\r\n    // allow any internal scripts to load\r\n    const { files } = __$ampere.config;\r\n    const ampereUrls = [\r\n      files.config,\r\n      files.client,\r\n      files.worker,\r\n      files.bundle\r\n    ].map((file) => files.directory + file);\r\n\r\n    const url = new URL(event.request.url);\r\n\r\n    // If the request is for a ampere file, we just fetch it\r\n    if (ampereUrls.includes(url.pathname)) {\r\n      __$ampere.logger.info(\"Loading ampere script\", url.href);\r\n      return fetch(event.request);\r\n    }\r\n\r\n    // Otherwise we proxy the request to the server\r\n    const rawProxyURL =\r\n      __$ampere.unwriteURL(url.pathname) + url.search + url.hash;\r\n\r\n    // error checking on URL\r\n    try {\r\n      new URL(rawProxyURL);\r\n    } catch {\r\n      __$ampere.logger.error(\"Decoded URL is invalid\", rawProxyURL);\r\n      return new Response(\"Invalid URL\", { status: 400 });\r\n    }\r\n\r\n    const proxyURL = new URL(rawProxyURL);\r\n\r\n    // request init for outgoing bare request\r\n    const requestInit: RequestInit & { duplex: \"half\" } = {\r\n      method: event.request.method,\r\n      headers: Object.fromEntries(event.request.headers),\r\n      redirect: \"manual\",\r\n      // Typescript doesn't believe in duplex but it's required for certain requests (and yes it's in the spec)\r\n      duplex: \"half\"\r\n    };\r\n\r\n    // request body for non-GET/HEAD requests\r\n    if (![\"GET\", \"HEAD\"].includes(event.request.method)) {\r\n      requestInit.body = event.request.body;\r\n    }\r\n\r\n    // create a request object\r\n    let request = new Request(proxyURL, requestInit);\r\n    const requestHeaders: Headers = await outgoing(\r\n      new Headers(requestInit.headers),\r\n      proxyURL\r\n    );\r\n\r\n    // make headers mutable\r\n    Object.defineProperty(request, \"headers\", {\r\n      get() {\r\n        return requestHeaders;\r\n      }\r\n    });\r\n\r\n    // emit request event\r\n    request = (await this.emit(\"request\", request)) ?? request;\r\n\r\n    // make a request to the server\r\n    const bareRequest = await this.makeRequest(proxyURL, requestInit);\r\n\r\n    // handle redirects\r\n    if (\r\n      bareRequest.status >= 300 &&\r\n      bareRequest.status < 400 &&\r\n      bareRequest.headers.has(\"location\")\r\n    ) {\r\n      __$ampere.logger.debug(\r\n        \"Redirecting from\",\r\n        proxyURL.href,\r\n        \"to\",\r\n        bareRequest.headers.get(\"location\")\r\n      );\r\n\r\n      return new Response(null, {\r\n        status: 301,\r\n        headers: {\r\n          location: __$ampere.rewriteURL(\r\n            bareRequest.headers.get(\"location\") as string,\r\n            proxyURL\r\n          )\r\n        }\r\n      });\r\n    }\r\n\r\n    // response init for outgoing response\r\n    const responseInit: ResponseInit = {\r\n      status: bareRequest.status,\r\n      statusText: bareRequest.statusText,\r\n      headers: await incoming(bareRequest.headers, proxyURL)\r\n    };\r\n\r\n    let responseBody: BodyInit | null;\r\n    if ([101, 204, 205, 304].includes(bareRequest.status)) {\r\n      // null response body for certain status codes\r\n      responseBody = null;\r\n      __$ampere.logger.info(\"Returning empty response for\", proxyURL.href);\r\n    } else if (bareRequest.headers.get(\"content-type\")?.includes(\"text/html\")) {\r\n      __$ampere.logger.info(\"Rewriting HTML for\", proxyURL.href);\r\n      let html = await bareRequest.text();\r\n\r\n      // emit pre:html event\r\n      html = (await this.emit(\"html\", html)) ?? html;\r\n      html = (await this.emit(\"pre:html\", html)) ?? html;\r\n\r\n      const cookie = await __$ampere.getCookie(proxyURL);\r\n\r\n      // rewrite HTML\r\n      html = __$ampere.rewriteHTML(html, proxyURL, cookie ?? \"\");\r\n\r\n      // emit post:html event\r\n      responseBody = (await this.emit(\"post:html\", html)) ?? html;\r\n    } else if (\r\n      bareRequest.headers\r\n        .get(\"content-type\")\r\n        ?.includes(\"application/javascript\") ||\r\n      // use || destination for non-strict mime type matching\r\n      [\"script\", \"sharedworker\", \"worker\"].includes(event.request.destination)\r\n    ) {\r\n      __$ampere.logger.info(\"Rewriting JS for\", proxyURL.href);\r\n      let js = await bareRequest.text();\r\n\r\n      // emit pre:js event\r\n      js = (await this.emit(\"js\", js)) ?? js;\r\n      js = (await this.emit(\"pre:js\", js)) ?? js;\r\n\r\n      // rewrite JS\r\n      js = __$ampere.rewriteJS(js, proxyURL);\r\n\r\n      // emit post:js event\r\n      responseBody = (await this.emit(\"post:js\", js)) ?? js;\r\n    } else if (\r\n      bareRequest.headers.get(\"content-type\")?.includes(\"text/css\") ||\r\n      // use || destination for non-strict mime type matching\r\n      [\"style\"].includes(event.request.destination)\r\n    ) {\r\n      __$ampere.logger.info(\"Rewriting CSS for\", proxyURL.href);\r\n      let css = await bareRequest.text();\r\n\r\n      // emit pre:css event\r\n      css = (await this.emit(\"css\", css)) ?? css;\r\n      css = (await this.emit(\"pre:css\", css)) ?? css;\r\n\r\n      // rewrite CSS\r\n      css = __$ampere.rewriteCSS(css, proxyURL);\r\n\r\n      // emit post:css event\r\n      responseBody = (await this.emit(\"post:css\", css)) ?? css;\r\n    } else if (event.request.destination === \"manifest\") {\r\n      __$ampere.logger.info(\"Rewriting Manifest for\", proxyURL.href);\r\n      let manifest = await bareRequest.text();\r\n\r\n      // emit pre:manifest event\r\n      manifest = (await this.emit(\"manifest\", manifest)) ?? manifest;\r\n      manifest = (await this.emit(\"pre:manifest\", manifest)) ?? manifest;\r\n\r\n      manifest = __$ampere.rewriteManifest(manifest, proxyURL);\r\n\r\n      // emit post:manifest event\r\n      responseBody = (await this.emit(\"post:manifest\", manifest)) ?? manifest;\r\n    } else {\r\n      __$ampere.logger.info(\"Returning binary for\", proxyURL.href);\r\n      responseBody = bareRequest.body;\r\n    }\r\n\r\n    let response = new Response(responseBody, responseInit);\r\n\r\n    // emit response event\r\n    response = (await this.emit(\"response\", response)) ?? response;\r\n\r\n    return response;\r\n  }\r\n}\r\n\r\nself.AmpereWorker = AmpereWorker;\r\n"],
  "mappings": "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",
  "names": ["value", "parse", "cookies", "target"]
}
